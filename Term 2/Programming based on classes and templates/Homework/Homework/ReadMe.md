# Домашнее задание

Описание для своей работы добавлю чуть позже.

## Обязательные требования

Приведенные ниже требования являются обязательными для выполнения в рамках ДЗ/КЛР. Для сдачи заданий и получения хорошей отметки они все должны быть выполнены в полном объеме..
При выполнении задания должны быть обязательно учтены следующие требования:

1. Студент разрабатывает: (1) систему классов, (2) демонстрационный пример ее использования и (3) комплект документации на программный продукт индивидуально. Должна быть разработана диаграмма классов.
**Пример.** Система классов улиц и домов. Полный комплект документации, включая ТЗ и ПМИ (см. ниже). Демонстрационный пример для проверки работы системы классов на основе ПМИ (документ Программа и Методика Испытаний). При отладке программ классов может быть использован отдельный пример для отладки.

2. Студентом должны быть разработаны, по крайней мере, три новых класса, отличных от стандартных классов систем программирования и других библиотек классов. Имена классов должны быть понятными и легко запоминаться. Рекомендуется использовать венгерскую нотацию для именования классов, их свойств и методов.
**Пример.** Два класса дом и улица уже есть (Home и Street – см. выше). Класс Home должен быть наследован от CObject, а класс Street от классов список или массив (см. варианты групп). Третий класс может быть определен как абстрактный класс для строений или улиц, для того чтобы иметь возможность развития классов: строения могут быть не только жилыми домами, но и магазинами, учреждениями и т.д. Стандартные классы используются для контейнеров (массивы и списки), а также для формирования свойств виртуальности – базовый объект (Например, CObject).

3. Для классов объектов явно определяются и разрабатываются: конструкторы (не менее трех конструкторов для каждого класса) и деструкторы (для каждого класса). Кроме этого, перегружается оператор присваивания объектов, и создается конструктор копирования на основе объекта.
**Пример.** Конструкторы могут с первоначальным заданием параметров или нет, например, с заданием названия улицы, номера дома и т.д.(см. выше).

4. В каждом классе помимо конструкторов и деструкторов должно быть определено не менее пяти методов (функций членов класса), а также не менее пяти индивидуальных свойств разных типов (данных класса). Обязательно должны быть реализованы разные стандартные типы: int, double, char массив (строка). В дополнение к ним могут быть заданы типы стандартной библиотеки. Использование класса string (из STL, и MFC) не допускается.
**Пример.** Методы для улиц могут быть такими: добавление дома, удаление дома, распечатки домов улицы, нумерация домов, сложение улиц, деление улиц и т.д. Например, деление улицы на две может интерпретироваться так: первые N домов переносятся на "улицу Горького", а остальные на "Тверскую". Т.е., другими словами, из одного объекта мы получаем два других объекта с определенными свойствами. Разрабатывая такую операцию нужно продумать вопросы: где создаются новые объекты, как они заполняться, уничтожается ли исходный объект и т.д.

5. Должно быть продемонстрировано использование механизмов наследования
классов для элементного и контейнерного класса. В каждом классе, как минимум, один класс должен быть базовым, а другой производным. Для класса контейнера (список или массив) наследование выполняется от стандартного контейнерного класса, заданного вариантом (список или массив) и собственного абстрактного класса. Таким образом должен быть продемонстрирован механизм множественного наследования.
**Пример.** Наследование, если это не определяются по-другому характером задачи желательно сделать также от абстрактного класса. Например, для дома или улицы.

6. Для элементного и контейнерного классов должны быть перегружены операции “+”, в алгоритм функции перегрузки которой, закладывается, по возможности, оригинальный и конкретный смысл операции. Кроме этого должна быть перегружена операция из группового варианта.
**Пример.** Операция сложения двух домов, например, при выполнении новой нумерации улицы или дополнительных построек домов (дом 2 строение 3.).

7. В одном из своих классов, по выбору, должны быть реализованы скрытые методы и данные, не менее 3-х (доступ private). Доступ к этим данным и методам должен быть выполнен только с помощью открытого метода класса, что должно быть продемонстрировано на примерах в демонстрационном примере.
**Пример.** Доступ к вычисляемому признаку ремонта домов улицы (скрытому - private) и метода расчета признака ремонта может быть выполнен отдельным методом.

8. В одном классе (элементном или контейнерном) на выбор определяется, как минимум, одна чистая виртуальная функция (это предопределяет использование одного абстрактного класса) и демонстрируется ее переопределение в других классах, для этого может быть создан дополнительный класс (типа Object). Функция затем переопределяется и демонстрируется е применение в проекте ДЗ.
**Пример.** Чистые виртуальные функции задаются в абстрактном классе и переопределяются в производных классах. Например, функция печати объекта на cout (например - printOn).

9. Один из разрабатываемых классов должен быть контейнерного типа (массив, список, множество и т.д.), в нем должны быть определены операции добавления, удаления, распечатки из контейнера и др. Должны учитываются дополнительные требования к данному классу, которые выделены в групповых и индивидуальных вариантах задания. Контейнерные свойства класса наследуются от стандартных контейнерных классов по варианту группы (список, массив). Операции с собственным контейнерным классом реализуются на основе методов и свойств базового класса. Допускается реализация собственных дополнительных базовых контейнерных классов (списки, массивы и т.д.), при этом они реализуются без наследования от классов стандартных библиотек (д.т.).
**Пример.** В контейнерном классе улица предусматриваются операции добавления домов, их удаления, печати всех домов улицы и т.д. Например, для определения числа объектов в контейнере для класса CArray может быть использован метод GetCount. Возможна собственная реализация классов список или массив.

10. В контейнерном классе, в зависимости от варианта, задается как минимум одна перегружаемая операция (см. обязательная операция, обозначенная знаком по варианту группы). Операция должна иметь внятный смысл и быть продемонстрирована на примере.
**Пример.** В нашем случае лучше определить операцию сложения двух улиц или операцию добавления дома на улицу. В первом случае это может выглядеть так:
Оператор присваивания сложения улиц: Street3 = Street1+ Street2;
а во втором простое выражение присваивания: Street1+Home1;

11. Отладка системы классов может быть выполнена с помощью специального отладочного примера, созданного в произвольной форме, однако предпочтительней является вариант с переключателем и отдельными блоками для проверки методов и свойств классов (конструкторы, методы, операции). Для проведения испытаний ПО ДЗ студенты разрабатывают отдельный документ ПМИ (см. ниже). Возможно, для проведения испытаний потребуется разработать и отдельный (не отладочный проект) тестовый пример и описать в документе ОТП – описание тестового примера (см. ниже).
**Пример.** В приложении к данным МУ можно посмотреть такой пример (Закомментированная функция mainDEBUG()).

12. Для сдачи работы, должен быть разработан, описан в документе и представлен специальный демонстрационный (тестовый) пример, иллюстрирующий работу всех возможностей разработанной системы классов – всех пунктов ТЗ (свойств и методов/функций членов). Он является основой для демонстрации и сдачи домашнего задания (в соответствии с пунктами ТЗ и ПИМ – программой и методикой испытаний). Все пункты ТЗ (раздел 5.1 технического задания) должны проверяться в тестовом примере. Можно использовать переключатель для обеспечения выборочной проверки пунктов ТЗ.
**Пример.** В демонстрационном примере (mainMETOD()) должны быть показано использование всех классов, на основе определения объектов и работу всех методов этих классов. Выполнение всех пунктов ТЗ. Он строится на основе консольного меню и переключателя. Например, для классов улиц: создание улиц статическое и динамическое через операцию new, уничтожение улиц через операцию delete, добавление домов на улицу, их удаление, распечатку домов, слияние улиц и т.д.

13. Описания классов и их методы должны быть вынесены в отдельные файлы – модули проекта (*.cpp, *.h или *.hpp). При этом необходимо исключить повторное включение описаний в исходный текст. Проектирование модульной структуры и распределение описаний по модулям выполняется в самом начале работы над проектом домашнего задания.
__Пример.__ Например, с помощью переменных этапа компиляции (define __STREET_H):
      #if !defined( __STREET_H ) #include <Street.h>
      #endif //

14. Должны быть предусмотрены специальные методы очистки (Clear) и распечатки контейнерного объекта (PrintOn).
**Пример.** Смотрите примеры в приложении.

15. Предусмотреть в классе методы для записи содержимого вашего контейнера в двоичный файл и восстановления содержимого контейнера из файла. Данный пункт должен быть в ТЗ для ДЗ, в разделе 5.1 и МПИ.
**Пример.** Запись в файл всех домов с улицы (StreetToFile и StreetFtomFile). Пока этих функций в примерах приложения нет.

16. После компиляции программ и создания исполнимого модуля (build) не должно наблюдаться любых предупреждений в окне фиксации ошибок. При необходимости преподаватель при демонстрации проекта может попросить скомпилировать модули и пересоздать проект.

Примечание: Контейнерные классы в домашнем задании должны
быть реализованы на основе стандартных классов типа списки и массивы из библиотек (по вариантам групп). Задания, реализованные на основе простых стандартных массивов объектов (например, для домов - Home[20]), приниматься к защите не будут.

### Требования к реализации контейнерных классов

В каждом задании на КЛР/ДЗ необходимо создать минимум один собственный контейнерный класс. Контейнерные классы (см. выше) – это такие классы, на основе которых создаются объекты, позволяющие включать в себя другие объекты или, по другому, хранить в себе. Это отношение накопления между классами. Контейнерные классы могут быть упорядоченными (массивы и списки) и неупорядоченными (множества). Для реализации контейнерных классов студенты могут выбрать один из подходов:

* Использование стандартных (библиотечных) классов типа список или массив, а собственный контейнерный класс наследовать от них. Все основные методы базового класса для выполнения операций наследуются.
* Создание собственных списков (или массивов) в контейнерном классе задания (например, в классе улиц) и реализация в них всех операций для работы над списками (массивами). Это менее универсальный вариант, но более трудоемкий способ реализации проекта задания (вариант из дополнительных требований). Он может быть полезен в учебном плане для подготовки программиста.
* Создание собственных отдельных базовых классов типа список и массив, с дальнейшим наследованием ваших контейнерных классов задания от них. Более универсальный вариант, но еще более трудоемкий случай (вариант также из дополнительных требований). Он может быть аналогично полезен в учебном плане для тренировки программиста.

Если студенты выбирают первый способ, то они должны использовать классы MS VS, которые записаны для отдельных требований групп (см. ниже).

## Дополнительные требования для сильных студентов

Для сильных студентов предлагается более сложный вариант задания. 

Во-первых, можно выбрать в таблице вариантов более сложный вариант задания (д.т.), согласовав выбранную тему с преподавателем.
Во-вторых, в стандартном задании можно выполнить следующие дополнительные требования:

1. Создать собственные классы для двунаправленных списков (или специальных динамических массивов) и использовать их для наследования в ваших тематических контейнерных классах.
2. Выполнить оригинальную перегрузку операций ввода/вывода в поток(<< , >>). Это нужно сделать и для элементного и контейнерного классов задания.
3. Использовать бинарные файлы для хранения информации из контейнерных классов. Для этого предусмотреть специальные конструкторы и деструкторы. Предусматривается загрузка и выгрузка из файлов из/в ОП. Возможна выборка объектов по номеру в контейнере и/или по условиям, наложенным на атрибуты элементных объектов.
4. Использовать динамически создаваемые объекты, включаемые в контейнер, с контролем создания и удаления объектов и их составляющих (например, для строковых полей класса). Предусмотреть возможность удаления и сохранения объектов после выборки из контейнера.

Студент может выбрать одно или несколько дополнительных требований и указать их содержание на титульных листах документов ДЗ. Выполнение дополнительных требований может быть полезно в учебном плане для тренировки программиста, а также учитывается при подведении итогов семестра по данной дисциплине (автоматы или значение отметки).

