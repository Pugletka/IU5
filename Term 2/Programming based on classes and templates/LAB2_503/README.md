# Лабораторная работа №2

## Пункт 4.3
 
### Выполнить операции ввода и вывода для переменных стандартных типов

Нужно ввести с консоли четыре переменные: типа int (iVal), типа double (dVal), типа bool (bVal) и строку типа char (sMas[100]). Строка завершается нулевым символом (NullTerminate – “\0”). Ввод и вывод должен выполняться с помощью перегруженных операций классов потокового ввода и вывода и соответственно с объектами cin (“>>”) и cout (“<<”). Ввод и вывод переменных оформить так (на примере целой переменной):

	Введите iVal: 10
	Было введено значение iVal = 10

Аналогично оформить ввод и вывод для других переменных (dVal, bVal и sMas). При выводе для логической переменной вывести значения: Истина/true и Ложь/false. При вводе строки убедитесь в том символе, который является ограничителем ввода строки. Найдите решение для ввода строки с ограничителем конца строки (“\n”) при использовании стандартных потоков.

Продемонстрировать использование указателей для вывода и ввода информации в потоках (cin и cout). 
Для этого нужно описать указатель на целую переменную (pInt = &iVal;).
Переменной нужно присвоить конкретное значение (например, число 5), а затем выполнить вывод переменной через указатель в потоке cout. Далее нужно ввести значение из потока cin  через этот указатель и снова переменную распечатать. 
Ввод вывод пояснить комментариями.

## Пункт 4.4

### Выполнить операции ввода и вывода с помощью методов get, getline, put, write

Продемонстрировать применение методов для стандартных потоков. Для cin: get, getline, а для cout: put, write.

## Пункт 4.5

### Продемонстрировать использование методов форматирования вывода в поток

Нужно продемонстрировать использование методов форматирования: setf,  fill, width, precision, unsetf. Для демонстрации форматирования вывода с помощью функций  fill и width нужно использовать введенную ранее строку SMas (width, fill, left и right).
Вывод должен выглядеть так:

	Введите строку sMas: ...
	Было введено значение sMas = ...

Для демонстрации метода precision(2) нужно использовать переменную dVal.

	Введите dVal: 5.12346
	Введено dVal =  5.12346
	До precision dVal =  5.12346
	После  cout.precision(2) dVal =  5.1

## Пункт 4.6

### Продемонстрировать использование манипуляторов для потоковых объектов

Нужно продемонстрировать использование манипуляторов (hex, dec, oct) форматирования прямо в потоке и с использованием методов setf и unsetf в отдельной строке программы. Не забудьте подключить заголовочный файл – iomanip. 
Вывод должен выглядеть так (можно не повторять в программе ввод iVal):

	Введите iVal: 17
	Введено iVal =  17
	hex iVal =  11
	dec iVal =  17
	oct iVal =  21
	Повторно после вызова cout.setf( ios_base::hex )   iVal =  17
	Повторно после вызова cout.unsetf( ios_base::hex )   iVal =  21

Нужно продемонстрировать использование манипуляторов форматирования: setbase, scientific, showbase, showpoint, setprecision. При демонстрации манипулятора setbase нужно получить (для числа 16):

	setbase(16) для 16 = 10
	setbase(10) для 16 = 16
	setbase(8) для 16 = 20

При демонстрации манипулятора scientific нужно получить:

	f = 5.2111  = 5.21110010e+000

При демонстрации манипулятора showbase нужно получить (вывод числа 12) такое:

	Для 12 hex - 0xc
	Для 12 oct - 014
	Для 12 dec - 12

## Пункт 4.7

### Продемонстрировать использование пользовательского манипулятора

Продемонстрировать использование пользовательского манипулятора hexbase для потока cout из теоретической части данных МУ. Нужно описать манипулятор и показать его использование в потоке вывода для переменной целого типа вашего проекта (iVal).

## Пункт 4.8

### Продемонстрировать вызов функций в потоках ввода и вывода и проектах

Для демонстрации вызова функций в потоке вывода создадим в проекте второй исходный файл (SECOND.CPP). Для этого в дереве проекта, на позиции “Source Files” вызываем контекстное меню, а там выбираем пункт “Add” - > “New Item”. Выбираем шаблон “C++ File”, а поле “Name” вводим имя файла - SECOND. В пустой файл добавляем описание заголовочных файлов и библиотеки std:

	#include <iostream>
	using namespace std;

В новом файле (SECOND.CPP) нужно описать функцию Spravka со следующим прототипом, прототип этой функции размещаем в начале основного файла проекта:

	char * Spravka(void);

Эта функция должна возвращать указатель на строку, содержащую: ФИО студента, индекс группы и номер варианта студента по списку группы. Для демонстрации функции вставляем в поток ее вызов:
   
	cout << Spravka() << endl;

Функция должна вывести в поток или передать строку информацию следующего вида ( с учетом актуальной фамилии, группы и варианта), например:

	Большаков Сергей, группа ИУ5-25, Вариант по списку № 3.

Для демонстрации доступа к переменным, объявленным в другом файле SECOND.CPP описываем глобальную переменную iSecond с инициализацией:

	int iSecond = 15;

В главном файле нужно описать внешние связи с данной переменной с помощью директивы extern:
   
	extern int iSecond ;

Для демонстрации доступа к глобальной переменной распечатаем ее с помощью потока вывода cout:
   
	cout << dec << "iSecond  = " <<  iSecond  << endl;

Далее нужно создать свою новую функцию в файле проекта SECOND.CPP и выполнить пример обращение к ней. Тип и название функции определяется вариантом (см. ниже). 
Тип функции может быть: int, long, float, char * или double. 
Продемонстрировать вызов своей функции из потока. Результат обращения распечатать.

## Пункт 4.9

### Вывод и вывод объектов пользовательских классов в стандартных потоках

Описать пользовательский тип (см. ниже варианты). Описывать структуру со служебным словом class.
После заголовка класса открыть все данные класса (public:). Методы класса не описывать. Описать для него функцию вывода содержания объекта (PrintXXX) с помощью операций потокового вывода (cout) в отдельном модуле SECOND.CPP. Описать для него функцию ввода содержания объекта (GetXXX) с помощью операций потокового ввода (cin) в отдельном модуле SECOND.CPP. В названии функции XXX – название вашего класса по варианту группы. Функции описывать как обычно, не делая их членами класса. Описать отдельно переменную нового типа с инициализацией. Распечатать ее функцией печати (PrintXXX), ввести ее заново функцией ввода (GetXXX), и снова распечатать.

## Пункт 4.10

### Работа с файлами в классах потокового ввода и вывода

#### СОЗДАНИЕ НОВОГО ФАЙЛА

Описать поток для вывода двоичного файла (ofstream) в режиме ios_base::out. Описать простой класс и массив его объектов (см. варианты.). В классе описывать только данные (в разделе public). Создать заполнить файл с именем “Var_GXX.bin”. Где: G – номер группы, а XX – вариант по журналу группы. Запись в файл выполнить на основе массива объектов/структур классов, заполненного при инициализации (см. варианты).  Использовать функции: open, write и close. Файл закрыть (функция close). Во всех заданиях этого пункта файл нужно открывать в двоичном режиме (ios_base::bin).

#### ЧТЕНИЕ И РАСПЕЧАТКА ФАЙЛА

Описать поток для вывода файла (ifstream). Открыть сформированный ранее файл для чтения (“Var_GXX.bin”). Использовать функции: open, read и close. Прочитать в цикле отдельные записи файла (в промежуточный буфер) и их распечатать с помощью функции печати структуры (PrintXXX). 
Использовать функции: open, read и close. Файл закрыть (функция close). 

#### ИЗМЕНЕНИЕ И РАСПЕЧАТКА ФАЙЛА 

Описать поток для вывода/вывода файла (fstream). Открыть снова файл  (“Var_GXX.bin”) для записи с добавлением (app). Описать и проинициализировать новую структурную переменную вашего типа (варианты). 
Проверить правильность открытия файла с помощью функции good. Добавить новую структурную переменную - запись в конец файла. Закрыть файл. Сбросить флаги функцией clear. Открыть измененный файл для чтения (in). Прочитать измененный файл и распечатать с помощью функции печати структуры (PrintXXX). 
Использовать функции: fopen, fwrite, read и fclose. Файл закрыть (функция close).

#### ЧТЕНИЕ ЗАПИСИ ПО НОМЕРУ 

Открыть свой файл  (“Var_GXX.bin”) в режиме чтения(in) для потока ввода (ifstream). Прочитать запись по номеру  из этого файла (номер – см. вариант). Считать, что записи в файле пронумерованы с 1-цы. 
Использовать функции: open, seekg, read и close. Распечатать прочтенную запись с помощью своей функции. Файл закрыть (функция close).

#### СОЗДАНИЕ НОВОГО ФАЙЛА

Открыть свой файл  (“Var_GXX.bin”) в режиме чтения(in) для потока ввода (ifstream). Создать новый файл (LR2.BIN – поток ofstream) на основе созданного ранее(“Var_GXX.bin”), заполняя его  только четными или нечетными записями (см. вариант) из существующего файла. Второй файл открывается в режиме перезаписи (trunc). Использовать функции: open, write, read и close. Закрыть оба файла (функция close). Открыть новый файл (LR2.BIN) для чтения и его распечатать своей функцией. Файл закрыть (функция close). Продемонстрировать преподавателю содержимое всех своих файлов с помощью файл – менеджеров (Far, Total Commander или, в крайнем случае, при отсутствии названных файл – менеджеров в программе NOTEPAD) в шестнадцатеричном режиме.

## Пункт 4.11

### Буферизация в файловых потоках ввода и вывода

Открыть свой файл  (“Var_GXX.bin”) в режиме чтения(in) для потока ввода (ifstream). Вывести в поток cout его содержимое с использованием функции получения указателя буфера ввода (rdbuf) таким образом:

	ifstream inbuf("LR2.bin"); // описание и открытие файла
	cout << hex << endl << inbuf.rdbuf() << endl; // Вывод всего файла

Объяснить преподавателю содержание вывода на консоль и просмотреть результат в файл – менеджере в текстовом и шестнадцатеричном формате.

## Пункт 4.12

### Дополнительные требования для сильных студентов

Для сильных студентов предлагаются дополнительные требования при выполнении ЛР №2. Эти требования могут быть выполнены в любой последовательности и в любом объеме. На титульном листе отчета по ЛР необходимо указать, что дополнительные требования выполнены. Нужно:

* Создать собственный манипулятор для потока cout с параметром и без параметров (см. вариант).
* Произвести перегрузку операций (“<<” и “>>”) для стандартных потоков ввода и вывода для своего пользовательского класса (тип класса определяется вариантом – см. ниже).
* Построить диаграмму классов для классов, связанных с классами: fstream, ifstream, ofstream и др. 
* Продемонстрировать перегрузку операций ввода и вывода (“<<” и “>>”) в/из файлов для своего класса (варианты).
* Продемонстрировать ввод и вывод для классов STL и MFC/ATL (vector, string, CPoint).
* Создать функции для своего файла: изменение записи по номеру, удаление записи по номеру, добавление записи по номеру.

--

Примечание 1: Все действия по программированию выполняются в интерактивном режиме с использованием 
отладчика. Студент должен уметь выполнить программу по шагам, установить точку останова, просмотреть 
в отладчике локальные и глобальные переменные.

Примечание 2: После выполнения перечисленных действий студенты: демонстрируют работу программы 
преподавателю, оформляют отчет на основе шаблона по лабораторной работе (см. приложение) и защищают 
ее, отвечая на контрольные вопросы представленные в данных методических указаниях.
