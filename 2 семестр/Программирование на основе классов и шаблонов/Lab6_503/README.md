# Лабораторная работа №6

## Пункт 4.1. Создать в VS 2005-12 и руссифицировать консольный проект

### ПРОЕКТ VS 

Последовательность действий для создания консольного проекта в VS описана в методических указаниях к ЛР № 1 для данного курса (ПКШ), смотрите на сайте дисциплины. Русификация ввода и вывода информации  в проекте для консольного режима выполняется на основе приемов, также показанных в методических указаниях к ЛР №1. 

## Пункт 4.2. Варианты для выполнения заданий ЛР 

### ВАРИАНТЫ

До начала выполнения ЛР необходимо познакомиться с таблицей вариантов для групп студентов (см. ниже) и выполнять задание следующих пунктов в соответствии со своим групповым вариантом. Кроме этого вам понадобиться знание индивидуального варианта ДЗ/КЛР, которое соответствует номеру в журнале группы для текущего семестра. Номер можно узнать у старосты, а содержание варианта по этому номеру представлено в отдельном файле вариантов на сайте дисциплины.  

## Пункт 4.3. Проверить работу вызова функций при ручном динамическом связывании 

### РУЧНОЕ СВЯЗЫВАНИЕ 

Описать два класса (Type1 и Type1) на основе материала теоретической части данных МУ и базовый класс Bas. Описать два объекта этих классов (Т1 и Т2) и указатель для Bas - pObj. Попеременно присвоить указателю значения адреса объектов и помощью переключателей для выполнения детализации типа вызываемой функции (см. в теоретической части) продемонстрировать вызов нужной функции в пошаговом режиме отладчика VS. 

## Пункт 4.4. Построить структуру классов для изучения виртуального вызова методов 

### СОЗДАНИЕ СИСТЕМЫ КЛАССОВ

Нужно в своем заголовочном файле проекта (LR6.H) описать четыре класса: Absrt - абстрактный, Deriv1 ,Deriv2 и Deriv3 названия классов изменять нельзя. Связи наследования организованы следующим образом: Absrt - абстрактный класс, наследованный от СObject (!!! из библиотеки MFC – добавляется заголовочный файл - atlcoll.h); Deriv1 - наследуется от Absrt, Deriv2 наследуется от Deriv1 и Deriv3 наследуется от Deriv1. Во всех классах предусмотреть виртуальный метод – print, который будет использоваться для демонстрации виртуального вызова. В классе Absrt является чистой виртуальной функцией, а в классах Deriv1 ,Deriv2 и Deriv3 в нем записывается текст для идентификации вызываемого класса. 

### ОПИСАНИЕ КЛАССОВ 

Классы Deriv1 ,Deriv2 и Deriv3, не являются абстрактными и имеют, по крайней мере, одну виртуальную функцию (print), определенную в классе Absrt в качестве  чистой виртуальной функции (тело такой функции обозначается так - "=0"). В таблице, расположенной ниже, приведены основные сведения о создаваемых классах. Для каждой группы задаются отдельные групповые варианты, связанные с типом используемых данных. Применительно к данному пункту задания – это тип переменной класса (long, float, int, double).  

| Класс - имя  | Тип класса | Тип члена | Тип метода | Название класса члена |
| -------------  | ------------- | ------------- | ------------- | ------------- |
| Absrt | Абстрактный (наследник класса СObject) | Данное | int (см. вар) | iPar(dPar, fPar, lPar) |
|  | | Метод | Конструктор | Abstr(int p) |
|  | | Метод | Конструктор | Abstr() |
|  | | Метод – чистый, виртуальный | void | print() |
| Deriv1 | Объектный (наследник Absrt) | Данное | int ( см. вар) | int (см. вар) iDPar(dDPar, fDPar, lDPar) |
|  | | Метод | Конструктор | Deriv1(int p) |
|  | | Метод | Конструктор | Deriv1() |
|  | | Метод – виртуальный | void | print() |
| Deriv2 | Объектный (наследник Deriv1) | Данное | int ( см. вар) | int (см. вар) iDPar(dDPar, fDPar, lDPar) |
|  | | Метод | Конструктор | Deriv2(int p) |
|  | | Метод | Конструктор | Deriv2() |
|  | | Метод – виртуальный | void | print() |
| Deriv3 | Объектный (наследник Deriv1) | Данное | int ( см. вар) | int (см. вар) iDPar(dDPar, fDPar, lDPar) |
|  | | Метод | Конструктор | Deriv3(int p) |
|  | | Метод | Конструктор | Deriv3() |
|  | | Метод – виртуальный | void | print() |


Виртуальный метод print может иметь вид: 

    virtual void print()   {  cout <<"Derv1 = "<< iDPar<< " Abstr = " << iPar << endl;} ; 

Результаты разработки системы классов внести в отчет. Шаблон отчета приведен в конце данного документа. 

## Пункт 4.5. Построить диаграмму классов для предыдущего пункта 


### ДИАГРАММА КЛАССОВ 

Необходимо поострить диаграмму классов для системы классов, описанных выше, и отобразить ее в отчете в виде диаграммы классов. В диаграмме отобразить связи наследования.  

## Пункт 4.6. Проверка описания объекта абстрактного класса 

### ПРОВЕРКА ОБЪЕКТОВ АБСТРАКТНОГО КЛАССА

Проверить в главной программе описание объектов для абстрактного класса Absrt. Результаты проверки занести в отчет, указав причину полученных результатов.  

## Пункт 4.7. Проверка созданных классов – описание объектов 

### ОПИСАНИЕ ОБЪЕКТОВ

В главной программе описать указатель и три объекта для созданной системы классов. Проверить компиляцию и сборку программы. Пример: 

    Abstr *pAbs; 
    Derv1 d1(33); 
    Derv2 d2(44); 
    Derv3 d3(66); 

## Пункт 4.8. Проверка вызова функции через объекты 
	
### ВЫЗОВЫ МЕТОДОВ ЧЕРЕЗ ОБЪЕКТ

Проверить в главной программе вызов функции print для созданных объектов через объект (для всех объектов), например: 

    d2.print(); 

Результаты вызова скопировать в отчет. 

## Пункт 4.9. Проверка вызова функции через указатель на объект 

### ВЫЗОВЫ МЕТОДОВ ЧЕРЕЗ УКАЗАТЕЛЬ НА ОБЪЕКТ

Проверить в главной программе вызов функции print для созданных объектов через указатель (для всех объектов), например: 

    Derv1 *pD2 = &d2; 
    pD2 ->print(); 

Результаты вызова скопировать в отчет. 

## Пункт 4.10. Проверка виртуального вызова функции  

### ВИРТУАЛЬНЫЙ ВЫЗОВ

Проверить в главной программе вызов функции print для созданных объектов через указатель на базовый класс (для всех трех объектов) – виртуальный вызов, например: 

    pAbs = &d2;
    pAbs->print(); 

В пошаговом режиме отладчика убедиться, что при виртуальном вызове производиться вызов функции, соответствующей нужному типу объекта. Результаты вызова скопировать в отчет. 

## Пункт 4.11. Описание объекта списка типа CObList 

### ОПИСАНИЕ ОБЪЕКТА СПИСОК

Описать объект класса CObList с названием ListDer. В справочной системе VS познакомиться с основными методами этого класса (CObList): AddTail, AddHead, GetHeadPosition, GetAt, GetNext, RemoveAt, FindIndex и RemoveAll (кроме этого, информацию можно получить в МУ к ЛР № 8 по дисциплине ПКШ). 

## Пункт 4.12. Занесение объектов в список трех типов 

### ФОРМИРОВАНИЕ СПИСКА

Занести с помощью трех циклов в список ListDer объекты 3-типов (методы AddTail или AddHead) для наших классов (Deriv1 ,Deriv2 и Deriv3). Число заносимых объектов каждого типа минимум два объекта.  Тип метода определяется вариантом. Объекты создать динамически (new), определить их разное содержание для основного класса и базового абстрактного класса. Построить блок схему алгоритма и отобразить ее в отчете (MS VISIO). 

## Пункт 4.13. Распечатка списка объектов с помощью виртуального вызова 
 
### РАСПЕЧАТКА СПИСКА

В главной программе с помощью одного цикла распечатать список с использованием виртуального вызова. Для печати использовать метод print. Выполнить виртуальный вызов функции. Для организации цикла использовать специальный тип POSITION (pos)  и методы: GetHeadPosition, GetAt и GetNext. Цикл завершить по условию - pos == NULL.  Результаты распечатки скопировать в отчет. Построить блок схему алгоритма и отобразить ее в отчете (MS VISIO). 

## Пункт 4.14. Виртуальные деструкторы  

### ВИРТУАЛЬНЫЕ ДЕСТРУКТОРЫ

Описать во всех классах (Absrt, Deriv1 ,Deriv2 и Deriv3) виртуальные деструкторы (см. выше) и в одном цикле обеспечить удаление объектов всего списка  ListDer. В деструкторах сделать печать идентифицирующую тип класса. Результаты удаления занести в отчет. 

## Пункт 4.15. Виртуальные классы  
 
### ВИРТУАЛЬНЫЕ КЛАССЫ

Построить новую структуру классов с виртуальными классами, на примере рассмотренном выше. Структура должна быть сходна с описанием, из раздела “Основные понятия”. Буквенные имена классов заданы в таблице групповых вариантов. Типы переменных в классах должны соответствовать таблицу вариантов группы. Продемонстрировать использование виртуальных классов с помощью распечатки любой переменной виртуального базового класса. Результаты печати отобразить в отчете. 
 
## Пункт 4.16. Контейнерный класс для варианта ДЗ/КЛР 

### КОНТЕЙНЕРНЫЙ КЛАСС ДЗ

Для своего контейнерного класса ДЗ/КЛР описать один абстрактный класс, от которого этот класс наследуется. Кроме того, обеспечить множественное наследование своего класса и от стандартного контейнерного класса по групповому варианту ДЗ/КЛР. В исходном абстрактном классе описать чистую виртуальную функцию для печати объекта контейнера. В своем контейнерном классе описать и реализовать виртуальную функцию печати. Продемонстрировать использование виртуального вызова для своего контейнерного класса. Распечатывать только параметры собственного контейнерного класса без распечатки списка/массива. 

## Пункт 4.17. Построить диаграмму классов для индивидуального варианта 

###ДИАГРАММА КЛАССОВ ДЗ

Построить диаграмму наследования классов, указав на связях типы виртуального наследования. Диаграмму отобразить в отчете (MS VISIO). 

## Пункт 4.18. Дополнительные требования для сильных студентов (д.т.) 

Для сильных студентов предлагаются дополнительные требования при выполнении ЛР №6. Эти требования могут быть выполнены в любой последовательности и в любом объеме. На титульном листе отчета по ЛР необходимо указать, что дополнительные требования выполнены. Нужно: 

* Удалить из списка элемент по номеру, указанному в таблице вариантов. Список после удаления повторно распечатать. 
* Проверить механизмы виртуальных классов для смешанного варианта виртуальных базовых классов и не виртуальных базовых классов. Нарисовать диаграмму классов. Результаты и выводы поместить в отчет. 
* Проверить сохранение или отсутствие механизма виртуального вызова функций в том случае, если цепочка описаний одной функции с ключевым словом virtual временно прерывается в середине дерева наследования классов. 
* Описать полностью свой контейнерный класс ДЗ/КЛР и проверить его работоспособность. 

## Пункт 5. Варианты по группам и студентам  

Ниже предствалена таблица вариантов по группам студентов. В данной работе не назначаются индивидуальные варианты для каждого конкретного студента. 

| Вариант №  | Группа | Типы переменной для класса | Номер удаляемого элемента (д.т.) | Занесение в список | Виртуальные классы - имена  |
| -------------  | ------------- | ------------- | ------------- | ------------- | ------------- |
| 1 | ИУ5 – 21 | int | 3 | Хвост | O, P ,Q, R |
| 2 | ИУ5 – 22 | float | 2 | Хвост | I, J, K, L |
| 3 | ИУ5 – 23 | double | 5 | Голова | Y, U, Z, X |
| 4 | ИУ5 – 24 | int | 6 | Хвост | A, F, C, D |
| 5 | СУЦ | long | 1 | Голова | E, F, G, H |

д.т – означает вариант для дополнительных требований. 

## Пункт 8. Контрольные вопросы к ЛР№6

1. Что такое проект в VS 2005? Для чего нужны проекты и в чем их преимущество? 
2. Поясните структуру объектов программы по диаграмме объектов? 
3. Что такое переменная этапа компиляции? Как она описывается? 
4. Что такое абстрактный класс? Дайте определение. Пример. 
5. Почему нельзя создавать объекты абстрактных классов? 
6. Что такое виртуальная функция ( ВФ)? Чистая  ВФ? Пример. 
7. Что такое виртуальный вызов?  
8. В чем преимущества виртуального вызова для программистов? 
9. Поясните записи – “pAbs ->print();” и “d2.print();”? 
10. Поясните запись – “ ((Abstr *)(ListDer.GetAt(pos)))->print();”? 
11. Что такое чистая виртуальная функция? Покажите ее в вашей  программе. 
12. Зачем для виртуального вызова нужен указатель на базовый класс? 
13. Как влияет использование виртуального вызова на размер программ? 
14. Что означает запись “pos = ListDer.GetHeadPosition()”? Поясните как программист. 
15. Что означает запись “ ListDer.RemoveAll()”? Поясните как программист. 
16. Что означает запись “ ListDer.GetNext( pos)”? Поясните как программист. 
17. Что означает запись “ListDer.RemoveAt(ListDer.FindIndex(1))”? Поясните как программист. 
18. Как  из списка типа CObList удалить все элементы? 
19. Как влияет использование виртуального вызова на изменяемость программ? 
20. Что такое виртуальный класс? 
21. Что такое виртуальный деструктор? 
22. Какая проблема решается при использовании виртуальных классов? 
23. Почему нельзя копировать объекты, наследованные от класса CObject? 
24. Чем отличается статическое и динамическое связывание? 
25. На каком этапе разработки и выполнении программ происходит статическое связывание? 
26. На каком этапе разработки и выполнении программ происходит динамическое связывание? 
27. В чем состоят преимущества динамического связывания, и как они могут использоваться в программах? 
28. Какие действия можно предпринять во время отладки программы с классами? 

 

