# Лабораторная работа №1

## Пункт 4.1. Создать в VS 2005 консольный проект (LAB1)

Для создания консольного проекта необходимо: 
* Запустить систему программирования VS 2005; 
* В меню “File” выбрать пункт “New” и в подменю выбрать позицию “Project…”; 
* В списке “Project types” выбрать “Visual C++/Win32”, а в списке “Templates” выбрать “Win32 Console Application”;  
* В поле “Name” ввести: LAB1_XDD (где X – номер группы, а DD – номер варианта по журналу группы текущего семестра. Например, для студента группы ИУ5-22 с вариантом 15 – введем – LAB1_215). Далее нажать “OK”; 
* В новом окне мастера проектов нажать “Next”.  Проверить настройки проекта: “Application Type” должно быть – “Console Application”, “Additional option” -> “Empty Project” должен быть выключен, “Add common header files”-> “MFC”  и “ATL”  должны быть включены. 
* Далее необходимо нажать кнопку “Finish”. Новый проект будет создан. 
* Необходимо убрать из главных моделей проекта (LAB1_XDD.CPP и LAB1_XDD.H) все лишнее. Этого: в файле LAB1_XDD.H (у нас в примере LAB1_215.H) уберем все, а в файле LAB1_XDD.CPP (LAB1_215.CPP) оставим следующий текст: 

		#include "lab1_215.h" 
		#include <iostream> 
		
		using namespace std; 
		
		void main(void) 
		{ … } 
 
* Для контроля правильности создания пустого проекта, нажмем  клавишу “F7”   для проверки создания программы (build) и “F5” для проверки ее выполнения (run/debug). Все перечисленные действия должны быть выполнены безошибочно. Для правильной компиляции вместо многоточия нужно вставить любой корректный оператор. Например: 

		cout << "Проверка настройки проекта" << endl; 

Так как, в большинстве случаев, кодировка текста будет неправильная, то нужно выполнить следующий пункт для русификации консольного ввода и вывода. 

## Пункт 4.2. Обеспечить русификацию консольного ввода и вывода 

Для корректного отображения текстов на русском языке и его ввода в окне командной строки (после первого запуска программы) нужно сделать настройки шрифта этого окна. Переключаем шрифт  в тип - Lucida Console. Выбираем настройки (после вывода консольного окна на экран, правой кнопкой вызываем системное меню): СВОЙСТВА->ШРИФТ -> Lucida Console). После переключения шрифта, на запрос в отдельном окошке нужно выбрать режим – “Для всех окон с данным именем!”. Для правильной русификации окна консоли, кроме этого, в самом начале главной программы нужно переключить кодовую страницу для вывода: 

		system(" chcp 1251 > nul"); 

Для приостановки завершения программы в консольном окне в конце ее работы можно вызвать паузу следующим образом (например, в конце текста программы): 

		system("PAUSE"); 

На экране появиться следующая строка (смотри ниже) и программа будет ожидать нажатия клавиши: 

		Для продолжения нажмите любую клавишу . . . 

Обратите внимание на то, что при другом способе локализации (setlocale(0,"rus");) не все работает правильно. Вывод на консоль и ввод с консоли выполняется правильно, но после этого введенные в консольном окне данные (например, строка) имеют другую кодировку и выводятся неверно! Можете сами это проверить. Поэтому предпочтительно использовать предложенный выше способ с переключением кодовой страницы. 

Примечание. Если вы затрудняетесь выполнить заданный пункт ЛР, обратитесь к разделу “Основные понятия”, где приведены примеры для иллюстрации данного пункта. 

Примечание. Все описания классов и шаблонов выполнять в заголовочном файле LAB1_XDD.H (у нас в примере LAB1_215.H). Описания объектов и вызов методов в основном файле: LAB1_XDD.CPP (LAB1_215.CPP). 

## Пункт 4.3. Варианты для выполнения заданий ЛР 

### ВАРИАНТЫ

До начала выполнения ЛР необходимо познакомиться с таблицей вариантов для групп студентов (см. ниже) и выполнять задание следующих пунктов в соответствии со своим вариантом.  

## Пункт 4.4. Выполнить описание переменных и массивов 

### ПЕРЕМЕННЫЕ
	
Описать и инициализировать переменные различных стандартных типов и продемонстрировать присваивание им значений соответствующих типов. Типы: int (iVar), long (lVar), char (cVar), float (fVar), double (dVar), bool (bVar).
Выполнить печать после инициализации и нового присваивания (на cout). 

### МАССИВЫ

Описать массивы различных стандартных типов и продемонстрировать присваивание им значений соответствующих типов (элементу массива с номером варианта студента по списку группы). Типы: int (iMas), long (lMas), char (cMas), float (fMas), dounle (dMas), bool (bMas). Массивы  iMas и fMas проинициализировать при описании. Массив iMas имеет две размерности. Проинициализированные массивы необходимо распечатать в цикле.

## Пункт 4.5. Продемонстрировать использование указателей и ссылок

### УКАЗАТЕЛИ НА ПЕРЕМЕННЫЕ
	
Выполнить описание указателя (pInt). Присвоить указателю адрес переменной типа int (iVar) и задать с помощью указателя значение (Например, 5). Распечатать значение  по указателю и значение самого указателя (адрес). Изменить значение с помощью указателя (на 10) и снова распечатать.  

### ССЫЛКИ НА ПЕРЕМЕННЫЕ
	
Выполнить описание ссылки (rInt). Присвоить ссылке адрес  переменной типа int (iVar) и задать с помощью ссылки новое значение (Например, 15). Распечатать значение ссылки и адрес ссылки (&rInt). Изменить значение по ссылке (Например, 15) и распечатать с помощью ссылки (rInt) и указателя(pInt).

### УКАЗАТЕЛИ НА ФУНКЦИИ
	
Предварительно описать две простые функции (fun1 и fun2), возвращающие разные целочисленные значения (int) и имеющие один целочисленный параметр (int). Описать указатель на функции (pFun) c заданным прототипом.
Продемонстрировать использование этого указателя для каждой функции, распечатав результат с вызовом функций по указателю.

## Пункт 4.6. Продемонстрировать использование структур данных

### ИНИЦИАЛИЗАЦИЯ СТРУКТУР
	
Опишите структуру данных, содержащую не менее 4-х полей, в соответствии с вариантами для каждой группы (Street). Шаблон структуры должен быть описан в подключаемом заголовочном файле (LAB1_XDD.H). Продемонстрируйте инициализацию структуры для простой структурной переменной. Опишите и проинициализируйте массив структурных переменных данного типа. 

### ВЫЧИСЛЕНИЕ СТРУКТУР
	
Опишите неинициализированную структурную переменную. Продемонстрируйте вычисление значений всех полей простой структурной переменной, Распечатайте структурную переменную до и после изменений. Результаты в cout.

### МАССИВ СТРУКТУР
	
Опишите и заполните при инициализации массив структур по вашему варианту (не менее 5-ти элементов массива). Распечатайте в цикле этот массив структур (используйте оператор цикла - while и функцию sizeof() – для определения размера массива в программе динамически).

## Пункт 4.7. Динамическая память для структурных переменных и массива структур

### ПЕРЕМЕННАЯ
	
Опишите указатель на простую переменную типа int (pdInt). Выделите динамическую память под переменную (new).
Присвойте (разыменование -*) динамической переменной значение (25) и распечатайте вместе с адресом указателя. Освободите динамическую память (delete). 
	
### СТРУКТУРНАЯ ПЕРЕМЕННАЯ
	
Опишите указатель на структурную переменную вашего типа (pdStr) – смотрите варианты. Выделите динамическую память под структурную переменную (new). Присвойте (->) полям динамической структурной переменной значения в соответствии с типом поля и распечатайте вместе с адресом указателя. Освободите динамическую память под структуру (delete). 

### МАССИВ СТРУКТУРНЫХ ПЕРЕМЕННЫХ
	
Выделить динамическую память под массив структурных переменных вашего типа (pdStr) – смотрите варианты. Элементов должно быть не менее 3-х (можно из структурного массива, описанного выше). Заполнить поля отдельных структурных переменных произвольными значениями (вручную или в цикле). Распечатать динамический массив структурных переменных.
Освободите динамическую память под структурный массив (delete). 

## Пункт 4.8. Использование циклов и операторов ветвления. 

### СОРТИРОВКА ДИНАМИЧЕСКОГО МАССИВА ЦЕЛЫХ
	
Создать динамический массив целых переменных типа int (указатель - pMas). Размер массива не менее 5-ти элементов.
Заполните массив произвольными (вручную) или  случайными (функция - rand) значениями. Выполните пузырьковую сортировку по варианту (возрастание или убывание). Использовать оператор цикла for. Результат до и после сортировки распечатать.
Освободите динамическую память под массив (delete).  

## Пункт 4.9. Продемонстрировать умение описать функцию и вызвать ее из другого модуля

### ДОБАВЛЕНИЕ МОДУЛЯ В ПРОЕКТ.
		
Для демонстрации умения описывать функции в другом модуле создадим в проекте второй исходный файл (SECOND.CPP). Для этого в дереве проекта, на позиции “Source Files” вызываем контекстное меню, а там выбираем пункт “Add” - > “New Item”. Выбираем шаблон “C++ File”, а поле “Name” вводим имя файла - SECOND. В пустой файл добавляем описание заголовочных файлов и библиотеки std:

### ПРОСТАЯ ФУНКЦИЯ.

В новом файле создаем функцию по варианту (сумма, произведение, максимум, минимум, среднее). Содержание функции - вычисление значений для вещественного массива (см. пункт описание fMas), передаваемое в качестве параметров в функцию. Размер массива также передается в качестве параметра. Название функции задайте самостоятельно. Не забудьте описать прототип функции в основном файле. Распечатать массив перед обращением к функции. Для реализации цикла используется оператор цикла, обозначенный в варианте группы (for, do или while). После вызова функции распечатать результаты ее работы в стандартный поток cout.

### ФУНКЦИЯ СОРТИРОВКИ. 

Описать и продемонстрировать использование функции для сортировки массива структур (SortMas в модуле SECOND.CPP). Тип сортировки задается параметром функции (убывание или возрастание). Распечатать в цикле исходный массив и массив после сортировки. Тип массива задается вариантом. 

## Пункт 4.10. Работы с файлами на основе массива структур 

### СОЗДАНИЕ ФАЙЛА
	
Описать дескриптор файла. Создать заполнить файл с именем “Var_GXX.bin”. Где: G – номер группы, а XX – вариант по журналу группы. Использовать функции: fopen, fwrite и fclose. Запись в файл выполнить на основе массива структурных переменных, заполненного ранее (п.4.6) или описанного заново.  Закрыть файл.  
	
### ЧТЕНИЕ И РАСПЕЧАТКА ФАЙЛА
	
Открыть сформированный ранее файл для чтения. Использовать функции: fopen, fread и fclose. Прочитать в цикле отдельные записи файла (в промежуточный буфер) и их распечатать. Закрыть файл.  

### ИЗМЕНЕНИЕ ФАЙЛА
	
Открыть снова это файл для записи с добавлением. Описать и проинициализировать новую структурную переменную вашего типа. Добавить эту запись в конец файла. Использовать функции: fopen, fwrite и fclose. Закрыть файл. Открыть измененный файл для чтения. Прочитать файл и распечатать. Закрыть файл.
	
### ЧТЕНИЕ ЗАПИСИ ПО НОМЕРУ
	
Открыть свой файл для чтения. Прочитать запись по номеру  из файла (номер – см. вариант). Считать, что записи в файле пронумерованы с 1-цы. Использовать функции: fopen, fseek,  fread и fclose. Распечатать прочтенную запись. Закрыть этот файл. 
	
### СОЗДАНИЕ НОВОГО ФАЙЛА
	
Создать новый файл (LR1.BIN) на основе первого – только четными записями (0, 2, …) из первого. Использовать функции: fopen, fwrite, fread и fclose. Закрыть эти файлы. Открыть новый файл (LR1.BIN) для чтения и его распечатать. Закрыть файл. Продемонстрировать преподавателю содержимое файлов с помощью файл – менеджеров (Far или Total Commander).
	
## Пункт 4.11. Дополнительные требования для сильных студентов

Для сильных студентов предлагаются дополнительные требования. Эти требования могут быть выполнены в любой последовательности и в любом объеме. На титульном листе отчета по ЛР необходимо указать, что дополнительные требования выполнены.

### ИСПОЛЬЗОВАНИЕ ДИРЕКТИВЫ typedef

Продемонстрировать использование директивы typedef для ссылок и указателей.

### ИСПОЛЬЗОВАНИЕ switch

Продемонстрировать использование оператора множественного ветвления – переключатель (switch).

### ИСПОЛЬЗОВАНИЕ МАКРОСОВ

Продемонстрировать использование макросов (#define), смотрите варианты.
	
### ИЗМЕНЕНИЕ ЗАПИСИ ПО НОМЕРУ

Написать фрагменты изменения записи по номеру и удаления записей.
	
### РАБОТА С ФАЙЛАМИ В ВИДЕ ФУНКЦИЙ

Оформить фрагменты текста основного задания с файлами в виде функций (чтение в массив, распечатка файла, запись из массива в файл, чтение записи по номеру).

### ИСПОЛЬЗОВАНИЕ string
	
Продемонстрировать использование типа string из библиотеки STL. Не забудьте подключить библиотеку строк заголовочной директивой: #include <string>

## Пункт 5. Варианты по группам и студентам  

Ниже предствалена таблица вариантов по группам студентов. В данной работе не назначаются индивидуальные варианты для каждого конкретного студента. 

| Вариант №  | Группа | Тип цикла | Содержание и тип функции | № зап. чт. | Тип структуры | Сортировка в цикле | Вид и название макроса (д.т.) |
| -------------  | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| 1 | ИУ5 – 21 | do | Сумма / int | 4 | Группа | Возрастание | Min: минимум из трех |
| 2 | ИУ5 – 22 | for | Произведение / float | 2 | Кафедра | Убывание | Max: максимум из трех |
| 3 | ИУ5 – 23 | for | Минимум / double | 3 | Улица | Возрастание | Avr: среднее из трех |
| 4 | ИУ5 – 24 | while | Максимум / int | 5 | Дом | Убывание | Cmp: сравнение двух |
| 5 | СУЦ | while | Среднее / float | 1 | Студент | Возрастание | Max: максимум из двух |

д.т – означает вариант для дополнительных требований. 

## Пункт 7. Контрольные вопросы к ЛР№1 

1. Что такое проект в VS 2005? Для чего нужны проекты и в чем их преимущество? 
2. Дайте определение понятия программа. 
3. Дайте определение понятия переменная. 
4. Дайте определение понятия массив. 
5. Дайте определение понятия константа. 
6. Дайте определение понятия составного оператора. 
7. Дайте определение понятия указателя. 
8. Какие основные операции можно выполнить для указателей? 
9. Дайте определение понятия ссылка. 
10. Чем отличаются ссылки и указатели? 
11. Что делается с помощью операции именования? 
12. Что делается с помощью операции разыменования? 
13. Для чего и как используется динамическая память? 
14. Какую функцию выполняет операция new? 
15. Какую функцию выполняет операция delete? 
16. Дайте определение понятия функция. 
17. Что такое прототип функции? 
18. Что такое описание функции? 
19. Что такое вызов функции? 
20. Что такое формальные параметры функции? 
21. Что такое фактические параметры? 
22. Для чего нужны библиотеки и как они подключаются? 
23. Дайте определение понятия структуры данных. 
24. Что такое квалифицированная ссылка? 
25. Дайте определение понятия условный оператор. 
26. Дайте определение понятия оператор цикла. 
27. Какие составляющие циклов вы знаете? 
28. Какие операторы цикла в С++ вы знаете?. 
29. Дайте определение понятия файл. 
30. Какие типы файлов вы знаете? 
31. Чем отличаются двоичные и текстовые файлы? 
32. Какие основные операции для работы с файлами вы знаете? 
33. Что такое модуль? Какими модули бывают? 
34. Какие программы создают объектные и исполнимые модули? 
35. Как связать модули по данным и по функциям? 
36. Для чего нужны блок-схемы программ, какие преимущества они дают? 
37. Какие основные действия можно предпринять при отладке программ? 
